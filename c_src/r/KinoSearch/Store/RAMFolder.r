/** @file */
/***********************************************

 !!!! DO NOT EDIT THIS FILE !!!!

 All content has been auto-generated by 
 the boilerplater.pl utility.

 See boilerplater's documentation for details.

 ***********************************************/



#ifndef R_KINO_RAMFOLDER
#define R_KINO_RAMFOLDER 1

#include "KinoSearch/Store/RAMFolder.h"

#define KINO_RAMFOLDER_BOILERPLATE

typedef void
(*kino_RAMFolder_destroy_t)(kino_RAMFolder *self);

typedef struct kino_OutStream*
(*kino_RAMFolder_open_outstream_t)(kino_RAMFolder *self, 
                              const struct kino_ByteBuf *filename);

typedef struct kino_OutStream*
(*kino_RAMFolder_safe_open_outstream_t)(kino_RAMFolder *self, 
                                   const struct kino_ByteBuf *filename);

typedef struct kino_InStream*
(*kino_RAMFolder_open_instream_t)(kino_RAMFolder *self,   
                             const struct kino_ByteBuf *filename);

typedef struct kino_VArray*
(*kino_RAMFolder_list_t)(kino_RAMFolder *self);

typedef chy_bool_t
(*kino_RAMFolder_file_exists_t)(kino_RAMFolder *self, 
                           const struct kino_ByteBuf *filename);

typedef void
(*kino_RAMFolder_rename_file_t)(kino_RAMFolder *self, 
                           const struct kino_ByteBuf* from, 
                           const struct kino_ByteBuf *to);

typedef void
(*kino_RAMFolder_delete_file_t)(kino_RAMFolder *self, 
                           const struct kino_ByteBuf *filename);

typedef struct kino_ByteBuf*
(*kino_RAMFolder_slurp_file_t)(kino_RAMFolder *self, 
                          const struct kino_ByteBuf *filename);

typedef void
(*kino_RAMFolder_close_f_t)(kino_RAMFolder *self);

#define Kino_RAMFolder_Clone(self) \
    (self)->_->clone((kino_Obj*)self)

#define Kino_RAMFolder_Destroy(self) \
    (self)->_->destroy((kino_Obj*)self)

#define Kino_RAMFolder_Equals(self, other) \
    (self)->_->equals((kino_Obj*)self, other)

#define Kino_RAMFolder_Hash_Code(self) \
    (self)->_->hash_code((kino_Obj*)self)

#define Kino_RAMFolder_Is_A(self, target_vtable) \
    (self)->_->is_a((kino_Obj*)self, target_vtable)

#define Kino_RAMFolder_To_String(self) \
    (self)->_->to_string((kino_Obj*)self)

#define Kino_RAMFolder_Serialize(self, target) \
    (self)->_->serialize((kino_Obj*)self, target)

#define Kino_RAMFolder_Open_OutStream(self, filename) \
    (self)->_->open_outstream((kino_Folder*)self, filename)

#define Kino_RAMFolder_Safe_Open_OutStream(self, filename) \
    (self)->_->safe_open_outstream((kino_Folder*)self, filename)

#define Kino_RAMFolder_Open_InStream(self, filename) \
    (self)->_->open_instream((kino_Folder*)self, filename)

#define Kino_RAMFolder_List(self) \
    (self)->_->list((kino_Folder*)self)

#define Kino_RAMFolder_File_Exists(self, filename) \
    (self)->_->file_exists((kino_Folder*)self, filename)

#define Kino_RAMFolder_Rename_File(self, from, to) \
    (self)->_->rename_file((kino_Folder*)self, from, to)

#define Kino_RAMFolder_Delete_File(self, filename) \
    (self)->_->delete_file((kino_Folder*)self, filename)

#define Kino_RAMFolder_Slurp_File(self, filename) \
    (self)->_->slurp_file((kino_Folder*)self, filename)

#define Kino_RAMFolder_Latest_Gen(self, base, ext) \
    (self)->_->latest_gen((kino_Folder*)self, base, ext)

#define Kino_RAMFolder_Close_F(self) \
    (self)->_->close_f((kino_Folder*)self)

struct KINO_RAMFOLDER_VTABLE {
    KINO_OBJ_VTABLE *_;
    chy_u32_t refcount;
    KINO_OBJ_VTABLE *parent;
    const char *class_name;
    kino_Obj_clone_t clone;
    kino_Obj_destroy_t destroy;
    kino_Obj_equals_t equals;
    kino_Obj_hash_code_t hash_code;
    kino_Obj_is_a_t is_a;
    kino_Obj_to_string_t to_string;
    kino_Obj_serialize_t serialize;
    kino_Folder_open_outstream_t open_outstream;
    kino_Folder_safe_open_outstream_t safe_open_outstream;
    kino_Folder_open_instream_t open_instream;
    kino_Folder_list_t list;
    kino_Folder_file_exists_t file_exists;
    kino_Folder_rename_file_t rename_file;
    kino_Folder_delete_file_t delete_file;
    kino_Folder_slurp_file_t slurp_file;
    kino_Folder_latest_gen_t latest_gen;
    kino_Folder_close_f_t close_f;
};

extern KINO_RAMFOLDER_VTABLE KINO_RAMFOLDER;

#ifdef KINO_USE_SHORT_NAMES
  #define RAMFolder kino_RAMFolder
  #define RAMFOLDER KINO_RAMFOLDER
  #define RAMFolder_new kino_RAMFolder_new
  #define RAMFolder_destroy kino_RAMFolder_destroy
  #define RAMFolder_open_outstream kino_RAMFolder_open_outstream
  #define RAMFolder_safe_open_outstream kino_RAMFolder_safe_open_outstream
  #define RAMFolder_open_instream kino_RAMFolder_open_instream
  #define RAMFolder_list kino_RAMFolder_list
  #define RAMFolder_file_exists kino_RAMFolder_file_exists
  #define RAMFolder_rename_file kino_RAMFolder_rename_file
  #define RAMFolder_delete_file kino_RAMFolder_delete_file
  #define RAMFolder_slurp_file kino_RAMFolder_slurp_file
  #define RAMFolder_close_f kino_RAMFolder_close_f
  #define RAMFolder_Clone Kino_RAMFolder_Clone
  #define RAMFolder_Destroy Kino_RAMFolder_Destroy
  #define RAMFolder_Equals Kino_RAMFolder_Equals
  #define RAMFolder_Hash_Code Kino_RAMFolder_Hash_Code
  #define RAMFolder_Is_A Kino_RAMFolder_Is_A
  #define RAMFolder_To_String Kino_RAMFolder_To_String
  #define RAMFolder_Serialize Kino_RAMFolder_Serialize
  #define RAMFolder_Open_OutStream Kino_RAMFolder_Open_OutStream
  #define RAMFolder_Safe_Open_OutStream Kino_RAMFolder_Safe_Open_OutStream
  #define RAMFolder_Open_InStream Kino_RAMFolder_Open_InStream
  #define RAMFolder_List Kino_RAMFolder_List
  #define RAMFolder_File_Exists Kino_RAMFolder_File_Exists
  #define RAMFolder_Rename_File Kino_RAMFolder_Rename_File
  #define RAMFolder_Delete_File Kino_RAMFolder_Delete_File
  #define RAMFolder_Slurp_File Kino_RAMFolder_Slurp_File
  #define RAMFolder_Latest_Gen Kino_RAMFolder_Latest_Gen
  #define RAMFolder_Close_F Kino_RAMFolder_Close_F
#endif /* KINO_USE_SHORT_NAMES */

#define KINO_RAMFOLDER_MEMBER_VARS \
    chy_u32_t  refcount; \
    struct kino_ByteBuf * path; \
    struct kino_Hash * ram_files

#ifdef KINO_WANT_RAMFOLDER_VTABLE
KINO_RAMFOLDER_VTABLE KINO_RAMFOLDER = {
    (KINO_OBJ_VTABLE*)&KINO_VIRTUALTABLE,
    1,
    (KINO_OBJ_VTABLE*)&KINO_FOLDER,
    "KinoSearch::Store::RAMFolder",
    (kino_Obj_clone_t)kino_Obj_clone,
    (kino_Obj_destroy_t)kino_RAMFolder_destroy,
    (kino_Obj_equals_t)kino_Obj_equals,
    (kino_Obj_hash_code_t)kino_Obj_hash_code,
    (kino_Obj_is_a_t)kino_Obj_is_a,
    (kino_Obj_to_string_t)kino_Obj_to_string,
    (kino_Obj_serialize_t)kino_Obj_serialize,
    (kino_Folder_open_outstream_t)kino_RAMFolder_open_outstream,
    (kino_Folder_safe_open_outstream_t)kino_RAMFolder_safe_open_outstream,
    (kino_Folder_open_instream_t)kino_RAMFolder_open_instream,
    (kino_Folder_list_t)kino_RAMFolder_list,
    (kino_Folder_file_exists_t)kino_RAMFolder_file_exists,
    (kino_Folder_rename_file_t)kino_RAMFolder_rename_file,
    (kino_Folder_delete_file_t)kino_RAMFolder_delete_file,
    (kino_Folder_slurp_file_t)kino_RAMFolder_slurp_file,
    (kino_Folder_latest_gen_t)kino_Folder_latest_gen,
    (kino_Folder_close_f_t)kino_RAMFolder_close_f
};
#endif /* KINO_WANT_RAMFOLDER_VTABLE */

#undef KINO_RAMFOLDER_BOILERPLATE


#endif /* R_KINO_RAMFOLDER */


/* Copyright 2007 Marvin Humphrey
 *
 * This program is free software; you can redistribute it and/or modify
 * under the same terms as Perl itself.
 */


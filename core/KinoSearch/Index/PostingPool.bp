parcel KinoSearch cnick Kino;

class KinoSearch::Index::PostingPool cnick PostPool
    extends KinoSearch::Util::SortExRun {

    Schema            *schema;
    CharBuf           *field;
    Lexicon           *lexicon;
    PostingList       *plist;
    MemoryPool        *mem_pool;
    I32Array          *doc_map;
    Obj              **scratch;
    u32_t              scratch_cap;
    u32_t              mem_thresh;
    i32_t              doc_base;
    i32_t              last_doc_id;
    u32_t              post_count;

    static PostingPool*
    init(PostingPool *self, Schema *schema, const CharBuf *field,
         MemoryPool *mem_pool);

    /** Sort_compare_t-compatible function for comparing two non-NULL
     * RawPosting objects. The <code>context</code> argument is unused.
     */
    static int
    compare_raw_postings(void *context, const void *va, const void *vb);

    /** Add an element to the cache.  Multiple elements need not be added in
     * sorted order.
     */
    void
    Add_Elem(PostingPool *self, Obj *elem);

    /** Add a field's inverted content.
     */
    abstract void
    Add_Inversion(PostingPool *self, Inversion *inversion, i32_t doc_id, 
                  float doc_boost, float length_norm);

    /** Iterate through postings currently in RAM.  Used when flushing cache
     * to disk.
     */
    RawPosting*
    Fetch_From_RAM(PostingPool *self);

    /** Zap the cache and scratch arrays to minimize RAM costs once a run has
     * been written to disk.
     */
    void
    Shrink(PostingPool *self);

    u32_t
    Refill(PostingPool *self);

    void
    Sort_Cache(PostingPool *self);

    int
    Compare(PostingPool *self, Obj **a, Obj **b);

    void
    Destroy(PostingPool *self);
}

/** PostingPool representing fresh content added this indexing session.
 */
class KinoSearch::Index::FreshPostingPool cnick FreshPostPool
    extends KinoSearch::Index::PostingPool {

    FieldType         *type;
    Posting           *posting;
    bool_t             flipped;
    i64_t              lex_start;
    i64_t              post_start;
    i64_t              lex_end;
    i64_t              post_end;

    static incremented FreshPostingPool*
    new(Schema *schema, const CharBuf *field, MemoryPool *mem_pool);

    static FreshPostingPool*
    init(FreshPostingPool *self, Schema *schema, const CharBuf *field,
         MemoryPool *mem_pool);

    void
    Destroy(FreshPostingPool *self);

    void
    Set_Lex_Start(FreshPostingPool *self, i64_t lex_start);

    void
    Set_Lex_End(FreshPostingPool *self, i64_t lex_end);

    void
    Set_Post_Start(FreshPostingPool *self, i64_t post_start);

    void
    Set_Post_End(FreshPostingPool *self, i64_t post_end);

    void
    Add_Inversion(FreshPostingPool *self, Inversion *inversion, i32_t doc_id,
                  float doc_boost, float length_norm);

    /** Prepare to read back postings from disk.
     */
    void
    Flip(FreshPostingPool *self, InStream *lex_instream, 
         InStream *post_instream, u32_t mem_thresh);
}

/** PostingPool representing content from an existing segment which is being
 * merged.
 */
class KinoSearch::Index::MergePostingPool cnick MergePostPool
    extends KinoSearch::Index::PostingPool {

    static incremented MergePostingPool*
    new(Schema *schema, const CharBuf *field, MemoryPool *mem_pool, 
        SegReader *reader, I32Array *doc_map = NULL, i32_t doc_base);

    static MergePostingPool*
    init(MergePostingPool *self, Schema *schema, const CharBuf *field, 
         MemoryPool *mem_pool, SegReader *reader, I32Array *doc_map = NULL,
         i32_t doc_base);

    void
    Destroy(MergePostingPool *self);

    void
    Set_Mem_Thresh(MergePostingPool *self, u32_t mem_thresh);
}

/* Private scan-only Lexicon helper class. 
*/
class KinoSearch::Index::PostingPool::RawLexicon cnick RawLex
    extends KinoSearch::Index::Lexicon {
    
    InStream      *instream;
    TermStepper   *term_stepper;
    TermStepper   *tinfo_stepper;
    i64_t          start;
    i64_t          end;

    static incremented RawLexicon*
    new(Schema *schema, const CharBuf *field, InStream *instream, 
        i64_t start, i64_t end);

    static RawLexicon*
    init(RawLexicon *self, Schema *schema, const CharBuf *field, 
         InStream *instream, i64_t start, i64_t end);

    void
    Destroy(RawLexicon *self);

    public bool_t 
    Next(RawLexicon *self);

    public Obj*
    Get_Term(RawLexicon *self);

    public i32_t
    Doc_Freq(RawLexicon *self);
}

/** Private scan-only PostingList helper class. 
 */
class KinoSearch::Index::PostingPool::RawPostingList cnick RawPList
    extends KinoSearch::Index::PostingList {
    
    Posting       *posting;
    InStream      *instream;
    i64_t          start;
    i64_t          end;

    static incremented RawPostingList*
    new(Schema *schema, const CharBuf *field, InStream *instream, 
        i64_t start, i64_t end);

    static RawPostingList*
    init(RawPostingList *self, Schema *schema, const CharBuf *field, 
         InStream *instream, i64_t lex_start, i64_t lex_end);

    void
    Destroy(RawPostingList *self);

    RawPosting*
    Read_Raw(RawPostingList *self, i32_t last_doc_id, CharBuf *term_text,
             MemoryPool *mem_pool);

    public Posting*
    Get_Posting(RawPostingList *self);
}

/* Copyright 2007-2009 Marvin Humphrey
 *
 * This program is free software; you can redistribute it and/or modify
 * under the same terms as Perl itself.
 */


parcel KinoSearch cnick Kino;

__C__
#include <stddef.h>
#include "KinoSearch/Object/Obj.h"
#include "KinoSearch/Util/SortUtils.h"

#define KINO_SORTEX_DEFAULT_MEM_THRESHOLD 0x1000000
#ifdef KINO_USE_SHORT_NAMES
  #define SORTEX_DEFAULT_MEM_THRESHOLD KINO_SORTEX_DEFAULT_MEM_THRESHOLD
#endif
__END_C__

/** Abstract external sorter.
 *
 * SortExternal objects are sort pools which allow you to sort large amounts
 * of data.  To achieve this, you Feed() all values into the SortExternal
 * object, Flip() the object from write mode to read mode, then Fetch() the
 * values one at a time in sorted order.
 *
 * It's expected that the total memory footprint of the sortable objects will
 * eventually exceed a specified threshold; at that point, the SortExternal
 * object will call the abstract method Flush().  It's expected that Flush()
 * implementations will empty out the current sort cache, write a sorted "run"
 * to external storage, and add a new child SortExternal object to the top
 * level object's "runs" array to represent the flushed content.
 *
 * During the read phase, the child objects retrieve values from external
 * storage one at a time by calling the abstract method Recover_Item().  The
 * top-level SortExternal object then interleaves multiple sorted streams to
 * produce a single unified stream of sorted values.
 */
abstract class KinoSearch::Util::SortExternal cnick SortEx
    extends KinoSearch::Object::Obj {

    Obj          **cache;
    u32_t          cache_cap;
    u32_t          cache_max;
    u32_t          cache_tick;
    Obj          **scratch;
    u32_t          scratch_cap;
    VArray        *runs;
    u32_t          num_slices;
    Obj         ***slice_starts;
    u32_t         *slice_sizes;
    u32_t          mem_thresh;
    u32_t          mem_consumed;
    bool_t         flipped;

    inert SortExternal*
    init(SortExternal *self, u32_t mem_thresh = 0x1000000);

    /** Compare two sortable elements.
     */
    abstract int
    Compare(SortExternal *self, Obj **a, Obj **b);

    /** Flush all elements currently in the cache.
     *
     * Presumably this entails sorting everything, writing the sorted elements
     * to disk, spawning a child object to represent those elements, and
     * adding that child to the top level object via Add_Run().
     */
    abstract void
    Flush(SortExternal *self);

    /** Recover individual elements from external storage in sorted order.
     * Returns NULL when the object decides that the cache is full enough.
     */
    abstract incremented Obj*
    Recover_Item(SortExternal *self);

    /** Add an item to the sort pool.  
     * 
     * @param item The element to add.
     */
    void
    Feed(SortExternal *self, decremented Obj *item);

    /** Flip the sortex from write mode to read mode.
     */
    void
    Flip(SortExternal *self);

    /** Fetch the next sorted item from the sort pool.  Invalid prior to
     * calling Flip(). Returns NULL when all elements have been exhausted.
     */
    incremented Obj*
    Fetch(SortExternal *self);

    /** Preview the next item that Fetch will return, but don't pop it.
     * Invalid prior to calling Flip().
     */
    Obj*
    Peek(SortExternal *self);

    /** Add a run to the sortex's collection.
     */
    void
    Add_Run(SortExternal *self, decremented SortExternal *run);

    /** Refill the cache, adding elements via Recover_Item() until it
     * returns NULL.  Return the number of elements recovered.  May only be
     * called when the cache is empty.
     */
    u32_t
    Refill(SortExternal *self);

    /** Sort all items currently in the main cache.
     */
    void
    Sort_Cache(SortExternal *self);

    /** Release items currently held in the cache, if any.  Reset all cache
     * variables (mem_consumed, cache_max, etc).
     */
    void
    Clear_Cache(SortExternal *self);

    /** Return the number of items presently in the cache.
     */
    u32_t
    Cache_Count(SortExternal *self);

    /** Allocate more memory to the cache.
     */
    void
    Grow_Cache(SortExternal *self, u32_t new_cache_cap);

    void 
    Set_Mem_Thresh(SortExternal *self, u32_t mem_thresh);

    public void
    Destroy(SortExternal *self);
}

/* Copyright 2006-2010 Marvin Humphrey
 *
 * This program is free software; you can redistribute it and/or modify
 * under the same terms as Perl itself.
 */

